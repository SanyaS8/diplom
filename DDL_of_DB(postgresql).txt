-- DROP SCHEMA transport_company;

CREATE SCHEMA transport_company AUTHORIZATION pg_database_owner;

COMMENT ON SCHEMA transport_company IS 'standard public schema';

-- DROP SEQUENCE transport_company.administrators_admin_id_seq;

CREATE SEQUENCE transport_company.administrators_admin_id_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 2147483647
	START 1
	CACHE 1
	NO CYCLE;
-- DROP SEQUENCE transport_company.auth_group_id_seq;

CREATE SEQUENCE transport_company.auth_group_id_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 2147483647
	START 1
	CACHE 1
	NO CYCLE;
-- DROP SEQUENCE transport_company.auth_group_permissions_id_seq;

CREATE SEQUENCE transport_company.auth_group_permissions_id_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 9223372036854775807
	START 1
	CACHE 1
	NO CYCLE;
-- DROP SEQUENCE transport_company.auth_permission_id_seq;

CREATE SEQUENCE transport_company.auth_permission_id_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 2147483647
	START 1
	CACHE 1
	NO CYCLE;
-- DROP SEQUENCE transport_company.auth_user_groups_id_seq;

CREATE SEQUENCE transport_company.auth_user_groups_id_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 9223372036854775807
	START 1
	CACHE 1
	NO CYCLE;
-- DROP SEQUENCE transport_company.auth_user_id_seq;

CREATE SEQUENCE transport_company.auth_user_id_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 2147483647
	START 1
	CACHE 1
	NO CYCLE;
-- DROP SEQUENCE transport_company.auth_user_user_permissions_id_seq;

CREATE SEQUENCE transport_company.auth_user_user_permissions_id_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 9223372036854775807
	START 1
	CACHE 1
	NO CYCLE;
-- DROP SEQUENCE transport_company.carriers_carrier_id_seq;

CREATE SEQUENCE transport_company.carriers_carrier_id_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 2147483647
	START 1
	CACHE 1
	NO CYCLE;
-- DROP SEQUENCE transport_company.cities_city_id_seq;

CREATE SEQUENCE transport_company.cities_city_id_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 2147483647
	START 1
	CACHE 1
	NO CYCLE;
-- DROP SEQUENCE transport_company.django_content_type_id_seq;

CREATE SEQUENCE transport_company.django_content_type_id_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 2147483647
	START 1
	CACHE 1
	NO CYCLE;
-- DROP SEQUENCE transport_company.django_migrations_id_seq;

CREATE SEQUENCE transport_company.django_migrations_id_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 9223372036854775807
	START 1
	CACHE 1
	NO CYCLE;
-- DROP SEQUENCE transport_company.payments_payment_id_seq;

CREATE SEQUENCE transport_company.payments_payment_id_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 2147483647
	START 1
	CACHE 1
	NO CYCLE;
-- DROP SEQUENCE transport_company.profile_profile_id_seq;

CREATE SEQUENCE transport_company.profile_profile_id_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 2147483647
	START 1
	CACHE 1
	NO CYCLE;
-- DROP SEQUENCE transport_company.routes_route_id_seq;

CREATE SEQUENCE transport_company.routes_route_id_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 2147483647
	START 1
	CACHE 1
	NO CYCLE;
-- DROP SEQUENCE transport_company.seats_seat_id_seq;

CREATE SEQUENCE transport_company.seats_seat_id_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 2147483647
	START 1
	CACHE 1
	NO CYCLE;
-- DROP SEQUENCE transport_company.tickets_ticket_id_seq;

CREATE SEQUENCE transport_company.tickets_ticket_id_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 2147483647
	START 1
	CACHE 1
	NO CYCLE;
-- DROP SEQUENCE transport_company.trips_trip_id_seq;

CREATE SEQUENCE transport_company.trips_trip_id_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 2147483647
	START 1
	CACHE 1
	NO CYCLE;
-- DROP SEQUENCE transport_company.users_user_id_seq;

CREATE SEQUENCE transport_company.users_user_id_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 2147483647
	START 1
	CACHE 1
	NO CYCLE;
-- DROP SEQUENCE transport_company.vehicles_vehicle_id_seq;

CREATE SEQUENCE transport_company.vehicles_vehicle_id_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 2147483647
	START 1
	CACHE 1
	NO CYCLE;-- transport_company.administrators определение

-- Drop table

-- DROP TABLE transport_company.administrators;

CREATE TABLE transport_company.administrators (
	admin_id serial4 NOT NULL,
	email varchar(100) NOT NULL,
	password_hash varchar(255) NOT NULL,
	created_at timestamp DEFAULT CURRENT_TIMESTAMP NULL,
	salt varchar(64) NULL,
	CONSTRAINT administrators_email_key UNIQUE (email),
	CONSTRAINT administrators_pkey PRIMARY KEY (admin_id)
);
CREATE INDEX idx_admin_email ON transport_company.administrators USING btree (email);
COMMENT ON TABLE transport_company.administrators IS 'Администраторы системы';


-- transport_company.auth_group определение

-- Drop table

-- DROP TABLE transport_company.auth_group;

CREATE TABLE transport_company.auth_group (
	id int4 GENERATED BY DEFAULT AS IDENTITY( INCREMENT BY 1 MINVALUE 1 MAXVALUE 2147483647 START 1 CACHE 1 NO CYCLE) NOT NULL,
	"name" varchar(150) NOT NULL,
	CONSTRAINT auth_group_name_key UNIQUE (name),
	CONSTRAINT auth_group_pkey PRIMARY KEY (id)
);
CREATE INDEX auth_group_name_a6ea08ec_like ON transport_company.auth_group USING btree (name varchar_pattern_ops);


-- transport_company.auth_user определение

-- Drop table

-- DROP TABLE transport_company.auth_user;

CREATE TABLE transport_company.auth_user (
	id int4 GENERATED BY DEFAULT AS IDENTITY( INCREMENT BY 1 MINVALUE 1 MAXVALUE 2147483647 START 1 CACHE 1 NO CYCLE) NOT NULL,
	"password" varchar(128) NOT NULL,
	last_login timestamptz NULL,
	is_superuser bool NOT NULL,
	username varchar(150) NOT NULL,
	first_name varchar(150) NOT NULL,
	last_name varchar(150) NOT NULL,
	email varchar(254) NOT NULL,
	is_staff bool NOT NULL,
	is_active bool NOT NULL,
	date_joined timestamptz NOT NULL,
	CONSTRAINT auth_user_pkey PRIMARY KEY (id),
	CONSTRAINT auth_user_username_key UNIQUE (username)
);
CREATE INDEX auth_user_username_6821ab7c_like ON transport_company.auth_user USING btree (username varchar_pattern_ops);


-- transport_company.carriers определение

-- Drop table

-- DROP TABLE transport_company.carriers;

CREATE TABLE transport_company.carriers (
	carrier_id serial4 NOT NULL,
	"name" varchar(100) NOT NULL,
	email varchar(100) NOT NULL,
	phone varchar(20) NULL,
	password_hash varchar(255) NOT NULL,
	created_at timestamp DEFAULT CURRENT_TIMESTAMP NULL,
	salt varchar(64) NULL,
	tin varchar(20) NULL, -- Taxpayer Identification Number (ИНН) of the carrier, unique for each carrier
	CONSTRAINT carriers_pkey PRIMARY KEY (carrier_id),
	CONSTRAINT unique_carrier_email UNIQUE (email),
	CONSTRAINT unique_carrier_name UNIQUE (name),
	CONSTRAINT unique_carrier_tin UNIQUE (tin)
);
CREATE INDEX idx_carrier_tin ON transport_company.carriers USING btree (tin);
COMMENT ON TABLE transport_company.carriers IS 'Информация о транспортных компаниях';

-- Column comments

COMMENT ON COLUMN transport_company.carriers.tin IS 'Taxpayer Identification Number (ИНН) of the carrier, unique for each carrier';


-- transport_company.cities определение

-- Drop table

-- DROP TABLE transport_company.cities;

CREATE TABLE transport_company.cities (
	city_id serial4 NOT NULL,
	"name" varchar(100) NOT NULL,
	country varchar(100) NOT NULL,
	CONSTRAINT cities_pkey PRIMARY KEY (city_id),
	CONSTRAINT unique_city_name_country UNIQUE (name, country)
);
COMMENT ON TABLE transport_company.cities IS 'Справочник городов для маршрутов';


-- transport_company.django_content_type определение

-- Drop table

-- DROP TABLE transport_company.django_content_type;

CREATE TABLE transport_company.django_content_type (
	id int4 GENERATED BY DEFAULT AS IDENTITY( INCREMENT BY 1 MINVALUE 1 MAXVALUE 2147483647 START 1 CACHE 1 NO CYCLE) NOT NULL,
	app_label varchar(100) NOT NULL,
	model varchar(100) NOT NULL,
	CONSTRAINT django_content_type_app_label_model_76bd3d3b_uniq UNIQUE (app_label, model),
	CONSTRAINT django_content_type_pkey PRIMARY KEY (id)
);


-- transport_company.django_migrations определение

-- Drop table

-- DROP TABLE transport_company.django_migrations;

CREATE TABLE transport_company.django_migrations (
	id int8 GENERATED BY DEFAULT AS IDENTITY( INCREMENT BY 1 MINVALUE 1 MAXVALUE 9223372036854775807 START 1 CACHE 1 NO CYCLE) NOT NULL,
	app varchar(255) NOT NULL,
	"name" varchar(255) NOT NULL,
	applied timestamptz NOT NULL,
	CONSTRAINT django_migrations_pkey PRIMARY KEY (id)
);


-- transport_company.django_session определение

-- Drop table

-- DROP TABLE transport_company.django_session;

CREATE TABLE transport_company.django_session (
	session_key varchar(40) NOT NULL,
	session_data text NOT NULL,
	expire_date timestamptz NOT NULL,
	CONSTRAINT django_session_pkey PRIMARY KEY (session_key)
);
CREATE INDEX django_session_expire_date_a5c62663 ON transport_company.django_session USING btree (expire_date);
CREATE INDEX django_session_session_key_c0390e0f_like ON transport_company.django_session USING btree (session_key varchar_pattern_ops);


-- transport_company.users определение

-- Drop table

-- DROP TABLE transport_company.users;

CREATE TABLE transport_company.users (
	user_id serial4 NOT NULL,
	email varchar(100) NOT NULL,
	password_hash varchar(255) NOT NULL,
	created_at timestamp DEFAULT CURRENT_TIMESTAMP NULL,
	salt varchar(64) NULL,
	CONSTRAINT users_email_key UNIQUE (email),
	CONSTRAINT users_pkey PRIMARY KEY (user_id)
);
COMMENT ON TABLE transport_company.users IS 'Зарегистрированные пользователи';


-- transport_company.auth_permission определение

-- Drop table

-- DROP TABLE transport_company.auth_permission;

CREATE TABLE transport_company.auth_permission (
	id int4 GENERATED BY DEFAULT AS IDENTITY( INCREMENT BY 1 MINVALUE 1 MAXVALUE 2147483647 START 1 CACHE 1 NO CYCLE) NOT NULL,
	"name" varchar(255) NOT NULL,
	content_type_id int4 NOT NULL,
	codename varchar(100) NOT NULL,
	CONSTRAINT auth_permission_content_type_id_codename_01ab375a_uniq UNIQUE (content_type_id, codename),
	CONSTRAINT auth_permission_pkey PRIMARY KEY (id),
	CONSTRAINT auth_permission_content_type_id_2f476e4b_fk_django_co FOREIGN KEY (content_type_id) REFERENCES transport_company.django_content_type(id) DEFERRABLE INITIALLY DEFERRED
);
CREATE INDEX auth_permission_content_type_id_2f476e4b ON transport_company.auth_permission USING btree (content_type_id);


-- transport_company.auth_user_groups определение

-- Drop table

-- DROP TABLE transport_company.auth_user_groups;

CREATE TABLE transport_company.auth_user_groups (
	id int8 GENERATED BY DEFAULT AS IDENTITY( INCREMENT BY 1 MINVALUE 1 MAXVALUE 9223372036854775807 START 1 CACHE 1 NO CYCLE) NOT NULL,
	user_id int4 NOT NULL,
	group_id int4 NOT NULL,
	CONSTRAINT auth_user_groups_pkey PRIMARY KEY (id),
	CONSTRAINT auth_user_groups_user_id_group_id_94350c0c_uniq UNIQUE (user_id, group_id),
	CONSTRAINT auth_user_groups_group_id_97559544_fk_auth_group_id FOREIGN KEY (group_id) REFERENCES transport_company.auth_group(id) DEFERRABLE INITIALLY DEFERRED,
	CONSTRAINT auth_user_groups_user_id_6a12ed8b_fk_auth_user_id FOREIGN KEY (user_id) REFERENCES transport_company.auth_user(id) DEFERRABLE INITIALLY DEFERRED
);
CREATE INDEX auth_user_groups_group_id_97559544 ON transport_company.auth_user_groups USING btree (group_id);
CREATE INDEX auth_user_groups_user_id_6a12ed8b ON transport_company.auth_user_groups USING btree (user_id);


-- transport_company.auth_user_user_permissions определение

-- Drop table

-- DROP TABLE transport_company.auth_user_user_permissions;

CREATE TABLE transport_company.auth_user_user_permissions (
	id int8 GENERATED BY DEFAULT AS IDENTITY( INCREMENT BY 1 MINVALUE 1 MAXVALUE 9223372036854775807 START 1 CACHE 1 NO CYCLE) NOT NULL,
	user_id int4 NOT NULL,
	permission_id int4 NOT NULL,
	CONSTRAINT auth_user_user_permissions_pkey PRIMARY KEY (id),
	CONSTRAINT auth_user_user_permissions_user_id_permission_id_14a6b632_uniq UNIQUE (user_id, permission_id),
	CONSTRAINT auth_user_user_permi_permission_id_1fbb5f2c_fk_auth_perm FOREIGN KEY (permission_id) REFERENCES transport_company.auth_permission(id) DEFERRABLE INITIALLY DEFERRED,
	CONSTRAINT auth_user_user_permissions_user_id_a95ead1b_fk_auth_user_id FOREIGN KEY (user_id) REFERENCES transport_company.auth_user(id) DEFERRABLE INITIALLY DEFERRED
);
CREATE INDEX auth_user_user_permissions_permission_id_1fbb5f2c ON transport_company.auth_user_user_permissions USING btree (permission_id);
CREATE INDEX auth_user_user_permissions_user_id_a95ead1b ON transport_company.auth_user_user_permissions USING btree (user_id);


-- transport_company.profile определение

-- Drop table

-- DROP TABLE transport_company.profile;

CREATE TABLE transport_company.profile (
	profile_id serial4 NOT NULL,
	user_id int4 NOT NULL,
	first_name varchar(100) NOT NULL,
	last_name varchar(100) NOT NULL,
	phone varchar(20) NOT NULL,
	birth_date date NOT NULL,
	passport_series varchar(10) NOT NULL,
	passport_number varchar(20) NOT NULL,
	CONSTRAINT profile_pkey PRIMARY KEY (profile_id),
	CONSTRAINT unique_passport UNIQUE (passport_series, passport_number),
	CONSTRAINT profile_user_id_fkey FOREIGN KEY (user_id) REFERENCES transport_company.users(user_id) ON DELETE CASCADE
);
CREATE INDEX idx_profile_user_id ON transport_company.profile USING btree (user_id);
COMMENT ON TABLE transport_company.profile IS 'Профили пользователей, содержащие персональные данные';


-- transport_company.routes определение

-- Drop table

-- DROP TABLE transport_company.routes;

CREATE TABLE transport_company.routes (
	route_id serial4 NOT NULL,
	departure_city_id int4 NOT NULL,
	arrival_city_id int4 NOT NULL,
	CONSTRAINT check_different_cities CHECK ((departure_city_id <> arrival_city_id)),
	CONSTRAINT routes_pkey PRIMARY KEY (route_id),
	CONSTRAINT routes_arrival_city_id_fkey FOREIGN KEY (arrival_city_id) REFERENCES transport_company.cities(city_id) ON DELETE RESTRICT,
	CONSTRAINT routes_departure_city_id_fkey FOREIGN KEY (departure_city_id) REFERENCES transport_company.cities(city_id) ON DELETE RESTRICT
);
COMMENT ON TABLE transport_company.routes IS 'Маршруты между городами';


-- transport_company.vehicles определение

-- Drop table

-- DROP TABLE transport_company.vehicles;

CREATE TABLE transport_company.vehicles (
	vehicle_id serial4 NOT NULL,
	carrier_id int4 NOT NULL,
	"type" varchar(20) NOT NULL,
	model varchar(100) NULL,
	total_seats int4 NOT NULL,
	vehicle_number varchar(50) NULL,
	CONSTRAINT vehicles_pkey PRIMARY KEY (vehicle_id),
	CONSTRAINT vehicles_total_seats_check CHECK ((total_seats > 0)),
	CONSTRAINT vehicles_carrier_id_fkey FOREIGN KEY (carrier_id) REFERENCES transport_company.carriers(carrier_id) ON DELETE RESTRICT
);
COMMENT ON TABLE transport_company.vehicles IS 'Транспортные средства перевозчиков';


-- transport_company.auth_group_permissions определение

-- Drop table

-- DROP TABLE transport_company.auth_group_permissions;

CREATE TABLE transport_company.auth_group_permissions (
	id int8 GENERATED BY DEFAULT AS IDENTITY( INCREMENT BY 1 MINVALUE 1 MAXVALUE 9223372036854775807 START 1 CACHE 1 NO CYCLE) NOT NULL,
	group_id int4 NOT NULL,
	permission_id int4 NOT NULL,
	CONSTRAINT auth_group_permissions_group_id_permission_id_0cd325b0_uniq UNIQUE (group_id, permission_id),
	CONSTRAINT auth_group_permissions_pkey PRIMARY KEY (id),
	CONSTRAINT auth_group_permissio_permission_id_84c5c92e_fk_auth_perm FOREIGN KEY (permission_id) REFERENCES transport_company.auth_permission(id) DEFERRABLE INITIALLY DEFERRED,
	CONSTRAINT auth_group_permissions_group_id_b120cbf9_fk_auth_group_id FOREIGN KEY (group_id) REFERENCES transport_company.auth_group(id) DEFERRABLE INITIALLY DEFERRED
);
CREATE INDEX auth_group_permissions_group_id_b120cbf9 ON transport_company.auth_group_permissions USING btree (group_id);
CREATE INDEX auth_group_permissions_permission_id_84c5c92e ON transport_company.auth_group_permissions USING btree (permission_id);


-- transport_company.trips определение

-- Drop table

-- DROP TABLE transport_company.trips;

CREATE TABLE transport_company.trips (
	trip_id serial4 NOT NULL,
	route_id int4 NOT NULL,
	vehicle_id int4 NOT NULL,
	departure_time timestamp NOT NULL,
	arrival_time timestamp NOT NULL,
	base_price numeric(10, 2) NOT NULL,
	status varchar(20) DEFAULT 'scheduled'::character varying NULL,
	distance_km numeric(10, 2) NOT NULL,
	trip_number varchar(20) NULL, -- Unique trip number (e.g., TR2025-001), required for each trip
	CONSTRAINT check_arrival_after_departure CHECK ((arrival_time > departure_time)),
	CONSTRAINT trips_base_price_check CHECK ((base_price >= (0)::numeric)),
	CONSTRAINT trips_distance_km_check CHECK ((distance_km > (0)::numeric)),
	CONSTRAINT trips_pkey PRIMARY KEY (trip_id),
	CONSTRAINT trips_status_check CHECK (((status)::text = ANY ((ARRAY['scheduled'::character varying, 'cancelled'::character varying, 'completed'::character varying])::text[]))),
	CONSTRAINT trips_trip_number_not_null CHECK ((trip_number IS NOT NULL)),
	CONSTRAINT trips_route_id_fkey FOREIGN KEY (route_id) REFERENCES transport_company.routes(route_id) ON DELETE RESTRICT,
	CONSTRAINT trips_vehicle_id_fkey FOREIGN KEY (vehicle_id) REFERENCES transport_company.vehicles(vehicle_id) ON DELETE RESTRICT
);
CREATE INDEX idx_trip_departure_time ON transport_company.trips USING btree (departure_time);
CREATE INDEX idx_trip_number ON transport_company.trips USING btree (trip_number);
COMMENT ON TABLE transport_company.trips IS 'Конкретные рейсы по маршрутам';

-- Column comments

COMMENT ON COLUMN transport_company.trips.trip_number IS 'Unique trip number (e.g., TR2025-001), required for each trip';

-- Table Triggers

create trigger trigger_cancel_tickets_on_trip_cancellation after
update
    of status on
    transport_company.trips for each row execute function transport_company.cancel_tickets_on_trip_cancellation();


-- transport_company.seats определение

-- Drop table

-- DROP TABLE transport_company.seats;

CREATE TABLE transport_company.seats (
	seat_id serial4 NOT NULL,
	vehicle_id int4 NOT NULL,
	trip_id int4 NOT NULL,
	seat_number varchar(10) NOT NULL,
	is_available bool DEFAULT true NULL,
	CONSTRAINT seats_pkey PRIMARY KEY (seat_id),
	CONSTRAINT unique_seat_per_trip UNIQUE (trip_id, seat_number),
	CONSTRAINT seats_trip_id_fkey FOREIGN KEY (trip_id) REFERENCES transport_company.trips(trip_id) ON DELETE CASCADE,
	CONSTRAINT seats_vehicle_id_fkey FOREIGN KEY (vehicle_id) REFERENCES transport_company.vehicles(vehicle_id) ON DELETE RESTRICT
);
CREATE INDEX idx_seat_trip_id ON transport_company.seats USING btree (trip_id);
COMMENT ON TABLE transport_company.seats IS 'Места в транспорте для рейсов';


-- transport_company.tickets определение

-- Drop table

-- DROP TABLE transport_company.tickets;

CREATE TABLE transport_company.tickets (
	ticket_id serial4 NOT NULL,
	user_id int4 NOT NULL,
	trip_id int4 NOT NULL,
	seat_id int4 NOT NULL,
	purchase_time timestamp DEFAULT CURRENT_TIMESTAMP NULL,
	price numeric(10, 2) NOT NULL,
	status varchar(20) DEFAULT 'booked'::character varying NULL,
	profile_id int4 NULL,
	CONSTRAINT tickets_pkey PRIMARY KEY (ticket_id),
	CONSTRAINT tickets_price_check CHECK ((price >= (0)::numeric)),
	CONSTRAINT tickets_status_check CHECK (((status)::text = ANY ((ARRAY['booked'::character varying, 'paid'::character varying, 'cancelled_by_user'::character varying, 'cancelled_by_trip'::character varying, 'archived'::character varying])::text[]))),
	CONSTRAINT unique_seat_per_ticket UNIQUE (seat_id),
	CONSTRAINT tickets_profile_id_fkey FOREIGN KEY (profile_id) REFERENCES transport_company.profile(profile_id) ON DELETE RESTRICT,
	CONSTRAINT tickets_seat_id_fkey FOREIGN KEY (seat_id) REFERENCES transport_company.seats(seat_id) ON DELETE RESTRICT,
	CONSTRAINT tickets_trip_id_fkey FOREIGN KEY (trip_id) REFERENCES transport_company.trips(trip_id) ON DELETE CASCADE,
	CONSTRAINT tickets_user_id_fkey FOREIGN KEY (user_id) REFERENCES transport_company.users(user_id) ON DELETE RESTRICT
);
CREATE INDEX idx_ticket_user_id ON transport_company.tickets USING btree (user_id);
COMMENT ON TABLE transport_company.tickets IS 'Информация о приобретенных билетах';


-- transport_company.payments определение

-- Drop table

-- DROP TABLE transport_company.payments;

CREATE TABLE transport_company.payments (
	payment_id serial4 NOT NULL,
	ticket_id int4 NOT NULL,
	amount numeric(10, 2) NOT NULL,
	payment_method varchar(20) NOT NULL,
	payment_status varchar(20) DEFAULT 'pending'::character varying NULL,
	payment_time timestamp DEFAULT CURRENT_TIMESTAMP NULL,
	CONSTRAINT payments_amount_check CHECK ((amount >= (0)::numeric)),
	CONSTRAINT payments_payment_method_check CHECK (((payment_method)::text = ANY ((ARRAY['card'::character varying, 'bank_transfer'::character varying, 'wallet'::character varying])::text[]))),
	CONSTRAINT payments_payment_status_check CHECK (((payment_status)::text = ANY ((ARRAY['pending'::character varying, 'completed'::character varying, 'failed'::character varying])::text[]))),
	CONSTRAINT payments_pkey PRIMARY KEY (payment_id),
	CONSTRAINT payments_ticket_id_fkey FOREIGN KEY (ticket_id) REFERENCES transport_company.tickets(ticket_id) ON DELETE CASCADE
);
CREATE INDEX idx_payment_ticket_id ON transport_company.payments USING btree (ticket_id);
COMMENT ON TABLE transport_company.payments IS 'Транзакции для оплаты билетов';



-- DROP FUNCTION transport_company.add_ticket(int4, int4, int4);

CREATE OR REPLACE FUNCTION transport_company.add_ticket(user_id_input integer, trip_id_input integer, profile_id_input integer)
 RETURNS text
 LANGUAGE plpgsql
AS $function$
DECLARE
    selected_seat_id INT;
    trip_price NUMERIC(10,2);
    trip_status VARCHAR(20);
    departure_time TIMESTAMP;
    new_ticket_id INT;
BEGIN
    -- Проверка существования пользователя
    IF NOT EXISTS (
        SELECT 1 FROM transport_company.users WHERE user_id = user_id_input
    ) THEN
        RAISE EXCEPTION 'User not found (ID: %)', user_id_input;
    END IF;

    -- Проверка существования рейса и его статуса
    SELECT status, base_price, departure_time
    INTO trip_status, trip_price, departure_time
    FROM transport_company.trips
    WHERE trip_id = trip_id_input;

    IF NOT FOUND THEN
        RAISE EXCEPTION 'Trip not found (ID: %)', trip_id_input;
    END IF;

    IF trip_status != 'scheduled' THEN
        RAISE EXCEPTION 'Trip not available (ID: %, status: %)', trip_id_input, trip_status;
    END IF;

    IF departure_time <= CURRENT_TIMESTAMP THEN
        RAISE EXCEPTION 'Trip already started (ID: %)', trip_id_input;
    END IF;

    -- Проверка существования профиля
    IF NOT EXISTS (
        SELECT 1 
        FROM transport_company.profile 
        WHERE profile_id = profile_id_input
    ) THEN
        RAISE EXCEPTION 'Profile not found (ID: %)', profile_id_input;
    END IF;

    -- Поиск первого свободного места
    SELECT seat_id
    INTO selected_seat_id
    FROM transport_company.seats
    WHERE trip_id = trip_id_input 
    AND is_available = true
    LIMIT 1 FOR UPDATE;

    IF NOT FOUND THEN
        RAISE EXCEPTION 'No available seats for trip (ID: %)', trip_id_input;
    END IF;

    -- Создание билета
    INSERT INTO transport_company.tickets (
        user_id, trip_id, seat_id, price, status, profile_id
    )
    VALUES (
        user_id_input, trip_id_input, selected_seat_id, trip_price, 'booked', profile_id_input
    )
    RETURNING ticket_id INTO new_ticket_id;

    -- Обновление места (занято)
    UPDATE transport_company.seats
    SET is_available = false
    WHERE seat_id = selected_seat_id;

    -- Создание записи в payments
    INSERT INTO transport_company.payments (
        ticket_id, amount, payment_method, payment_status
    )
    VALUES (
        new_ticket_id, trip_price, 'card', 'pending'
    );

    -- Возврат сообщения
    RETURN 'Successfully created';
END;
$function$
;

COMMENT ON FUNCTION transport_company.add_ticket(int4, int4, int4) IS 'Creates a ticket for a user on the specified trip with the given profile, occupying the first available seat, using base_price, creating a payment record, and returning "Successfully created"';

-- DROP FUNCTION transport_company.add_trip(int4, int4, int4, varchar, varchar, int4, varchar, timestamp, timestamp, numeric, numeric);

CREATE OR REPLACE FUNCTION transport_company.add_trip(carrier_id_input integer, departure_city_id_input integer, arrival_city_id_input integer, vehicle_type_input character varying, vehicle_model_input character varying, total_seats_input integer, vehicle_number_input character varying, departure_time_input timestamp without time zone, arrival_time_input timestamp without time zone, base_price_input numeric, distance_km_input numeric)
 RETURNS integer
 LANGUAGE plpgsql
AS $function$
DECLARE
    route_id_found INT;
    vehicle_id_found INT;
    new_trip_id INT;
    seat_num INT;
BEGIN
    -- Проверка существования перевозчика
    IF NOT EXISTS (
        SELECT 1 FROM transport_company.carriers WHERE carrier_id = carrier_id_input
    ) THEN
        RAISE EXCEPTION 'Carrier not found (ID: %)', carrier_id_input;
    END IF;

    -- Проверка существования городов
    IF NOT EXISTS (
        SELECT 1 FROM transport_company.cities WHERE city_id = departure_city_id_input
    ) THEN
        RAISE EXCEPTION 'Departure city not found (ID: %)', departure_city_id_input;
    END IF;

    IF NOT EXISTS (
        SELECT 1 FROM transport_company.cities WHERE city_id = arrival_city_id_input
    ) THEN
        RAISE EXCEPTION 'Arrival city not found (ID: %)', arrival_city_id_input;
    END IF;

    -- Проверка, что города разные
    IF departure_city_id_input = arrival_city_id_input THEN
        RAISE EXCEPTION 'Departure and arrival cities must be different';
    END IF;

    -- Проверка количества мест
    IF total_seats_input <= 0 THEN
        RAISE EXCEPTION 'Total seats must be positive';
    END IF;

    -- Проверка времени
    IF departure_time_input <= CURRENT_TIMESTAMP THEN
        RAISE EXCEPTION 'Departure time must be in the future';
    END IF;

    IF arrival_time_input <= departure_time_input THEN
        RAISE EXCEPTION 'Arrival time must be after departure time';
    END IF;

    -- Проверка цены и дистанции
    IF base_price_input < 0 THEN
        RAISE EXCEPTION 'Base price must be non-negative';
    END IF;

    IF distance_km_input <= 0 THEN
        RAISE EXCEPTION 'Distance must be positive';
    END IF;

    -- Поиск или создание маршрута
    SELECT route_id
    INTO route_id_found
    FROM transport_company.routes
    WHERE departure_city_id = departure_city_id_input
    AND arrival_city_id = arrival_city_id_input;

    IF NOT FOUND THEN
        INSERT INTO transport_company.routes (
            departure_city_id, arrival_city_id
        )
        VALUES (
            departure_city_id_input, arrival_city_id_input
        )
        RETURNING route_id INTO route_id_found;
    END IF;

    -- Поиск или создание транспорта
    SELECT vehicle_id
    INTO vehicle_id_found
    FROM transport_company.vehicles
    WHERE carrier_id = carrier_id_input
    AND type = vehicle_type_input
    AND model = vehicle_model_input
    AND total_seats = total_seats_input
    AND vehicle_number = vehicle_number_input;

    IF NOT FOUND THEN
        INSERT INTO transport_company.vehicles (
            carrier_id, type, model, total_seats, vehicle_number
        )
        VALUES (
            carrier_id_input, vehicle_type_input, vehicle_model_input,
            total_seats_input, vehicle_number_input
        )
        RETURNING vehicle_id INTO vehicle_id_found;
    END IF;

    -- Проверка доступности транспорта
    IF EXISTS (
        SELECT 1
        FROM transport_company.trips
        WHERE vehicle_id = vehicle_id_found
        AND (
            (departure_time_input BETWEEN departure_time AND arrival_time)
            OR (arrival_time_input BETWEEN departure_time AND arrival_time)
            OR (departure_time_input <= departure_time AND arrival_time_input >= arrival_time)
        )
    ) THEN
        RAISE EXCEPTION 'Vehicle is not available for the specified time (Vehicle ID: %)', vehicle_id_found;
    END IF;

    -- Создание рейса
    INSERT INTO transport_company.trips (
        route_id, vehicle_id, departure_time, arrival_time, base_price, status, distance_km
    )
    VALUES (
        route_id_found, vehicle_id_found, departure_time_input, arrival_time_input,
        base_price_input, 'scheduled', distance_km_input
    )
    RETURNING trip_id INTO new_trip_id;

    -- Создание мест
    FOR seat_num IN 1..total_seats_input LOOP
        INSERT INTO transport_company.seats (
            vehicle_id, trip_id, seat_number, is_available
        )
        VALUES (
            vehicle_id_found, new_trip_id, seat_num::TEXT, true
        );
    END LOOP;

    -- Возврат ID нового рейса
    RETURN new_trip_id;
END;
$function$
;

COMMENT ON FUNCTION transport_company.add_trip(int4, int4, int4, varchar, varchar, int4, varchar, timestamp, timestamp, numeric, numeric) IS 'Creates a new trip by finding or creating a route and vehicle, generates seats numbered from 1, and returns the trip ID';

-- DROP FUNCTION transport_company.add_trip(int4, int4, int4, varchar, varchar, int4, varchar, timestamp, timestamp, numeric, numeric, varchar);

CREATE OR REPLACE FUNCTION transport_company.add_trip(carrier_id_input integer, departure_city_id_input integer, arrival_city_id_input integer, vehicle_type_input character varying, vehicle_model_input character varying, total_seats_input integer, vehicle_number_input character varying, departure_time_input timestamp without time zone, arrival_time_input timestamp without time zone, base_price_input numeric, distance_km_input numeric, trip_number_input character varying)
 RETURNS integer
 LANGUAGE plpgsql
AS $function$
DECLARE
    route_id_found INT;
    vehicle_id_found INT;
    new_trip_id INT;
    seat_num INT;
BEGIN
    -- Проверка перевозчика
    IF NOT EXISTS (
        SELECT 1 FROM transport_company.carriers WHERE carrier_id = carrier_id_input
    ) THEN
        RAISE EXCEPTION 'Carrier not found (ID: %)', carrier_id_input;
    END IF;

    -- Проверка городов
    IF NOT EXISTS (
        SELECT 1 FROM transport_company.cities WHERE city_id = departure_city_id_input
    ) THEN
        RAISE EXCEPTION 'Departure city not found (ID: %)', departure_city_id_input;
    END IF;

    IF NOT EXISTS (
        SELECT 1 FROM transport_company.cities WHERE city_id = arrival_city_id_input
    ) THEN
        RAISE EXCEPTION 'Arrival city not found (ID: %)', arrival_city_id_input;
    END IF;

    IF departure_city_id_input = arrival_city_id_input THEN
        RAISE EXCEPTION 'Departure and arrival cities must be different';
    END IF;

    -- Проверка мест
    IF total_seats_input <= 0 THEN
        RAISE EXCEPTION 'Total seats must be positive';
    END IF;

    -- Проверка времени
    IF departure_time_input <= CURRENT_TIMESTAMP THEN
        RAISE EXCEPTION 'Departure time must be in the future';
    END IF;

    IF arrival_time_input <= departure_time_input THEN
        RAISE EXCEPTION 'Arrival time must be after departure time';
    END IF;

    -- Проверка цены и дистанции
    IF base_price_input < 0 THEN
        RAISE EXCEPTION 'Base price must be non-negative';
    END IF;

    IF distance_km_input <= 0 THEN
        RAISE EXCEPTION 'Distance must be positive';
    END IF;

    -- Поиск или создание маршрута
    SELECT route_id
    INTO route_id_found
    FROM transport_company.routes
    WHERE departure_city_id = departure_city_id_input
    AND arrival_city_id = arrival_city_id_input;

    IF NOT FOUND THEN
        INSERT INTO transport_company.routes (
            departure_city_id, arrival_city_id
        )
        VALUES (
            departure_city_id_input, arrival_city_id_input
        )
        RETURNING route_id INTO route_id_found;
    END IF;

    -- Поиск или создание транспорта
    SELECT vehicle_id
    INTO vehicle_id_found
    FROM transport_company.vehicles
    WHERE carrier_id = carrier_id_input
    AND type = vehicle_type_input
    AND model = vehicle_model_input
    AND total_seats = total_seats_input
    AND vehicle_number = vehicle_number_input;

    IF NOT FOUND THEN
        INSERT INTO transport_company.vehicles (
            carrier_id, type, model, total_seats, vehicle_number
        )
        VALUES (
            carrier_id_input, vehicle_type_input, vehicle_model_input,
            total_seats_input, vehicle_number_input
        )
        RETURNING vehicle_id INTO vehicle_id_found;
    END IF;

    -- Проверка доступности транспорта
    IF EXISTS (
        SELECT 1
        FROM transport_company.trips
        WHERE vehicle_id = vehicle_id_found
        AND (
            (departure_time_input BETWEEN departure_time AND arrival_time)
            OR (arrival_time_input BETWEEN departure_time AND arrival_time)
            OR (departure_time_input <= departure_time AND arrival_time_input >= arrival_time)
        )
    ) THEN
        RAISE EXCEPTION 'Vehicle is not available for the specified time (Vehicle ID: %)', vehicle_id_found;
    END IF;

    -- Создание рейса
    INSERT INTO transport_company.trips (
        route_id, vehicle_id, departure_time, arrival_time, base_price, status, distance_km, trip_number
    )
    VALUES (
        route_id_found, vehicle_id_found, departure_time_input, arrival_time_input,
        base_price_input, 'scheduled', distance_km_input, trip_number_input
    )
    RETURNING trip_id INTO new_trip_id;

    -- Создание мест
    FOR seat_num IN 1..total_seats_input LOOP
        INSERT INTO transport_company.seats (
            vehicle_id, trip_id, seat_number, is_available
        )
        VALUES (
            vehicle_id_found, new_trip_id, seat_num::TEXT, true
        );
    END LOOP;

    -- Возврат ID рейса
    RETURN new_trip_id;
END;
$function$
;

COMMENT ON FUNCTION transport_company.add_trip(int4, int4, int4, varchar, varchar, int4, varchar, timestamp, timestamp, numeric, numeric, varchar) IS 'Creates a trip with route, vehicle, seats from 1, assigns a non-unique trip number, returns trip ID';

-- DROP FUNCTION transport_company.cancel_tickets_on_trip_cancellation();

CREATE OR REPLACE FUNCTION transport_company.cancel_tickets_on_trip_cancellation()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
    IF NEW.status = 'cancelled' THEN
        UPDATE transport_company.tickets
        SET status = 'cancelled_by_trip'
        WHERE trip_id = NEW.trip_id AND status IN ('booked', 'paid');
        UPDATE transport_company.seats
        SET is_available = true
        WHERE trip_id = NEW.trip_id;
    END IF;
    RETURN NEW;
END;
$function$
;

COMMENT ON FUNCTION transport_company.cancel_tickets_on_trip_cancellation() IS 'Обновляет статус билетов на cancelled_by_trip при отмене рейса';

-- DROP FUNCTION transport_company.delete_trip(int4);

CREATE OR REPLACE FUNCTION transport_company.delete_trip(trip_id_input integer)
 RETURNS text
 LANGUAGE plpgsql
AS $function$
DECLARE
    trip_status VARCHAR(20);
    departure_time TIMESTAMP;
BEGIN
    -- Проверка существования рейса
    SELECT status, departure_time
    INTO trip_status, departure_time
    FROM transport_company.trips
    WHERE trip_id = trip_id_input;

    IF NOT FOUND THEN
        RAISE EXCEPTION 'Trip not found (ID: %)', trip_id_input;
    END IF;

    -- Проверка статуса рейса
    IF trip_status = 'completed' THEN
        RAISE EXCEPTION 'Cannot delete completed trip (ID: %)', trip_id_input;
    END IF;

    -- Проверка времени отправления
    IF departure_time <= CURRENT_TIMESTAMP THEN
        RAISE EXCEPTION 'Cannot delete trip that has already started (ID: %)', trip_id_input;
    END IF;

    -- Обновление статуса билетов
    UPDATE transport_company.tickets
    SET status = 'cancelled_by_trip'
    WHERE trip_id = trip_id_input
    AND status NOT IN ('archived', 'cancelled_by_trip');

    -- Удаление мест
    DELETE FROM transport_company.seats
    WHERE trip_id = trip_id_input;

    -- Удаление рейса
    DELETE FROM transport_company.trips
    WHERE trip_id = trip_id_input;

    -- Возврат сообщения
    RETURN 'Successfully deleted';
END;
$function$
;

COMMENT ON FUNCTION transport_company.delete_trip(int4) IS 'Deletes a trip by ID, removes associated seats, sets ticket status to cancelled_by_trip, returns Successfully deleted';

-- DROP FUNCTION transport_company.search_trips_by_cities(varchar, varchar, varchar, varchar);

CREATE OR REPLACE FUNCTION transport_company.search_trips_by_cities(city1_name character varying, country1_name character varying, city2_name character varying, country2_name character varying)
 RETURNS TABLE(trip_id integer, departure_time timestamp without time zone, arrival_time timestamp without time zone, distance_km numeric, base_price numeric, status character varying, departure_city character varying, arrival_city character varying, total_seats integer, available_seats bigint, model character varying, vehicle_number character varying, type character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN
    RETURN QUERY
    SELECT 
        t.trip_id,
        t.departure_time,
        t.arrival_time,
        t.distance_km,
        t.base_price,
        t.status,
        c1.name AS departure_city,
        c2.name AS arrival_city,
        v.total_seats,
        COALESCE((
            SELECT COUNT(*) 
            FROM transport_company.seats s 
            WHERE s.trip_id = t.trip_id AND s.is_available = true
        ), 0) AS available_seats,
        v.model,
        v.vehicle_number,
        v.type
    FROM transport_company.routes r
    JOIN transport_company.cities c1 ON r.departure_city_id = c1.city_id
    JOIN transport_company.cities c2 ON r.arrival_city_id = c2.city_id
    JOIN transport_company.trips t ON r.route_id = t.route_id
    JOIN transport_company.vehicles v ON t.vehicle_id = v.vehicle_id
    WHERE 
        c1.name = city1_name 
        AND c1.country = country1_name
        AND c2.name = city2_name
        AND c2.country = country2_name;
END;
$function$
;

COMMENT ON FUNCTION transport_company.search_trips_by_cities(varchar, varchar, varchar, varchar) IS 'Возвращает список рейсов для маршрута между указанными городами (с учётом стран), включая общее и свободное количество мест, модель, номер и тип транспорта';

-- DROP FUNCTION transport_company.user_tickets(int4);

CREATE OR REPLACE FUNCTION transport_company.user_tickets(user_id_input integer)
 RETURNS TABLE(ticket_id integer, departure_time timestamp without time zone, arrival_time timestamp without time zone, price numeric, status character varying, type character varying, model character varying, vehicle_number character varying, distance_km numeric, carrier_name character varying, seat_number character varying, departure_city character varying, arrival_city character varying, first_name character varying, last_name character varying, payment_status character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN
    RETURN QUERY
    SELECT 
        t.ticket_id,
        tr.departure_time,
        tr.arrival_time,
        t.price,
        t.status,
        v.type,
        v.model,
        v.vehicle_number,
        tr.distance_km,
        c.name AS carrier_name,
        s.seat_number,
        c1.name AS departure_city,
        c2.name AS arrival_city,
        p.first_name,
        p.last_name,
        pm.payment_status
    FROM transport_company.tickets t
    JOIN transport_company.trips tr ON t.trip_id = tr.trip_id
    JOIN transport_company.seats s ON t.seat_id = s.seat_id
    JOIN transport_company.vehicles v ON tr.vehicle_id = v.vehicle_id
    JOIN transport_company.carriers c ON v.carrier_id = c.carrier_id
    JOIN transport_company.routes r ON tr.route_id = r.route_id
    JOIN transport_company.cities c1 ON r.departure_city_id = c1.city_id
    JOIN transport_company.cities c2 ON r.arrival_city_id = c2.city_id
    LEFT JOIN transport_company.profile p ON t.user_id = p.user_id
    LEFT JOIN transport_company.payments pm ON t.ticket_id = pm.ticket_id
    WHERE t.user_id = user_id_input;
END;
$function$
;

COMMENT ON FUNCTION transport_company.user_tickets(int4) IS 'Возвращает информацию о билетах пользователя, включая детали рейса, транспорта, перевозчика, города, профиль и статус оплаты';